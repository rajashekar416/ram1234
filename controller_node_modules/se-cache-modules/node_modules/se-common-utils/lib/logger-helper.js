(function() {
  var bunyan, defaultLogger, fs, getDefaultLogger, packageJson, path, requireDir, routeAccessLogMiddleware, uncaughtExceptionHandlerBound, util, _, _bindUncaughtExceptionHandler, _controllerSerializer, _loadStreams, _moduleSerializer, _monitorLogLevels, _patchReqIdInjection, _reqSerializer;

  util = require('util');

  bunyan = require('bunyan');

  packageJson = require(process.cwd() + '/package.json');

  _ = require('lodash');

  requireDir = require('require-dir');

  fs = require('fs');

  path = require('path');

  defaultLogger = null;

  uncaughtExceptionHandlerBound = false;

  _bindUncaughtExceptionHandler = function() {
    if (!uncaughtExceptionHandlerBound) {
      uncaughtExceptionHandlerBound = true;
      return process.on('uncaughtException', function(err) {
        if (defaultLogger != null) {
          defaultLogger.error(err, "\u2622 UncaughtException \u2622");
        } else {
          console.error("\u2622 UncaughtException \u2622: " + err.message);
          console.error(err.stack);
        }
        return process.exit(1);
      });
    }
  };

  /**
   * Converts objects with key 'controller'
   * @param  {Object} controller a controller model instance
   * @return {Object}            a sanitized controller instance
  */


  _controllerSerializer = function(controller) {
    var _ref;
    if ((controller != null) && !_.isString(controller)) {
      controller = {
        uuid: (_ref = controller.name) != null ? _ref : controller.uuid,
        deviceName: controller.deviceName
      };
    }
    return controller;
  };

  /**
   * Converts objects with key 'req'
   * @param  {Object} req the http request object
   * @return {Object}     the sanitized request object
  */


  _reqSerializer = function(req) {
    var _ref, _ref1;
    if (((req != null ? req.connection : void 0) != null) || ((req != null ? req.headers : void 0) != null)) {
      req = {
        method: req.method,
        url: req.url,
        header: req.headers,
        userId: (_ref = req.user) != null ? _ref._id : void 0,
        username: (_ref1 = req.user) != null ? _ref1.username : void 0
      };
    }
    return req;
  };

  /**
   * Converts a module object to its filename
   * @param  {Object} module a module instance
   * @return {String}        the module's filename
  */


  _moduleSerializer = function(module) {
    if ((module != null ? module.filename : void 0) != null) {
      module = path.basename(module.filename);
    }
    return module;
  };

  /**
   * Loads bunyan stream modules from a given directory
   * @return {Array} an array of stream modules
  */


  _loadStreams = function(streamsPath) {
    var nodeEnv, streams;
    if (streamsPath != null) {
      nodeEnv = process.env.NODE_ENV || 'development';
      streams = _.values(requireDir(streamsPath));
      return streams = _.filter(streams, function(stream) {
        var eligible;
        eligible = _.contains(stream.env, nodeEnv);
        if (eligible && _.isFunction(stream.init)) {
          stream.init();
        }
        return eligible;
      });
    }
  };

  /**
   * Monitors the log levels file and changes corresponding
   * streams' log level accordingly
   * @param  {String} optionFilePath the path to the config file
  */


  _monitorLogLevels = function(optionFilePath) {
    var refreshLevels, refreshing;
    refreshing = false;
    refreshLevels = function() {
      refreshing = true;
      defaultLogger.debug("Reloading log levels", optionFilePath);
      return setTimeout(function() {
        var err, stream, streamOptions, _i, _len, _ref;
        delete require.cache[require.resolve(optionFilePath)];
        streamOptions = require(optionFilePath);
        try {
          _ref = defaultLogger.streams;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            stream = _ref[_i];
            defaultLogger.levels(stream.name, streamOptions[stream.name]);
          }
        } catch (_error) {
          err = _error;
          defaultLogger.error(err);
        }
        return refreshing = false;
      }, 100);
    };
    if (optionFilePath != null) {
      refreshLevels();
      return fs.watchFile(optionFilePath, function(curr, prev) {
        if (!refreshing) {
          return refreshLevels();
        }
      });
    }
  };

  /**
   * Injects the active execution context ID in the log message
   * if it exists
  */


  _patchReqIdInjection = function() {
    var origEmit;
    origEmit = bunyan.prototype._emit;
    return bunyan.prototype._emit = function(rec, noemit) {
      if (process.domain != null) {
        rec.req_id = process.domain.id;
      }
      return origEmit.call(this, rec, noemit);
    };
  };

  /**
   * Middleware logging express routes' accesses
   * @param  {String} level  the min level at which logs will be emitted
  */


  routeAccessLogMiddleware = function(level) {
    var expressBunyan;
    if (level == null) {
      level = 'trace';
    }
    expressBunyan = require('express-bunyan-logger')({
      genReqId: false,
      logger: defaultLogger
    });
    return function(req, res, next) {
      if ((bunyan.levelFromName[level] >= defaultLogger.level()) && req.method !== 'OPTIONS') {
        return expressBunyan(req, res, next);
      } else {
        return next();
      }
    };
  };

  /**
   * Returns the default logger with its serializers and
   * streams initialized and bound
   * @return {Object} a bunyan logger
  */


  getDefaultLogger = function(streamsPath) {
    if (defaultLogger == null) {
      defaultLogger = bunyan.createLogger({
        name: packageJson.name,
        level: 'debug',
        serializers: {
          req: _reqSerializer,
          res: bunyan.stdSerializers.res,
          err: bunyan.stdSerializers.err,
          controller: _controllerSerializer,
          module: _moduleSerializer
        },
        streams: _loadStreams(streamsPath)
      });
    }
    return defaultLogger;
  };

  module.exports = {
    routeAccessLogMiddleware: routeAccessLogMiddleware,
    logger: function(_arg) {
      var globalize, handleUncaughtExceptions, logLevelsConfPath, logger, streamsPath, _ref;
      _ref = _arg != null ? _arg : {}, streamsPath = _ref.streamsPath, logLevelsConfPath = _ref.logLevelsConfPath, globalize = _ref.globalize, handleUncaughtExceptions = _ref.handleUncaughtExceptions;
      if (handleUncaughtExceptions) {
        _bindUncaughtExceptionHandler();
      }
      _patchReqIdInjection();
      logger = getDefaultLogger(streamsPath);
      _monitorLogLevels(logLevelsConfPath);
      if (globalize) {
        global.logger = logger;
      }
      return logger;
    }
  };

}).call(this);
