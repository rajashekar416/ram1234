(function() {
  var DEFAULT_SETTINGS, SERVICE_KEY_FORMAT, ServiceInfoCache, _, logger, netUtils, util,
    slice = [].slice;

  util = require('util');

  _ = require('lodash');

  netUtils = require('se-common-utils').netUtils;

  logger = require('se-logger-helper').logger();

  SERVICE_KEY_FORMAT = 'service_nodes_%s';

  DEFAULT_SETTINGS = {
    ttlMillis: 10000,
    update2ttlRatio: 0.8,
    memCache2ttlRatio: 0.2,
    ip: netUtils.getNetworkAddress()
  };


  /**
   * Service info cache maintains a map of <service-name> to <service-ips> in redis
   * Creating an service info cache registers the current instance's ip in the cache.
   * This entry is then periodically updated with a timestamp to indicate that it is still alive.
   * Entries with an expired timestamp are purged from the cache.
   */

  ServiceInfoCache = (function() {
    function ServiceInfoCache(redisClientManager, serviceName, settings) {
      this.redisClientManager = redisClientManager;
      if (settings == null) {
        settings = DEFAULT_SETTINGS;
      }
      this._settings = _.merge({}, DEFAULT_SETTINGS, settings);
      this._cache = {};
      this._cacheTtlMillis = this._settings.ttlMillis * this._settings.memCache2ttlRatio;
      this._register(serviceName);
    }

    ServiceInfoCache.prototype._register = function(serviceName) {
      var _update, ip, key, updateInterval;
      key = util.format(SERVICE_KEY_FORMAT, serviceName);
      ip = this._settings.ip;
      updateInterval = this._settings.ttlMillis * this._settings.update2ttlRatio;
      _update = (function(_this) {
        return function() {
          var data, redisClient;
          data = JSON.stringify({
            lastSeen: Date.now()
          });
          redisClient = _this.redisClientManager.getPrimaryCacheClient();
          return redisClient.hset(key, ip, data, function(err) {
            if (err != null) {
              logger.error(err, "hset failed", {
                key: key,
                subKey: ip,
                data: data
              });
            }
            return _this._updateTimeoutId = setTimeout(_update, updateInterval);
          });
        };
      })(this);
      return _update();
    };

    ServiceInfoCache.prototype.stop = function() {
      if (this._updateTimeoutId != null) {
        return clearTimeout(this._updateTimeoutId);
      }
    };


    /**
     * returns a random node for the specified service
     */

    ServiceInfoCache.prototype.getRandomNode = function(serviceName, done) {
      return this.getNodes(serviceName, function(err, nodes) {
        var idx, node;
        if (err != null) {
          return done(err);
        } else if (nodes.length === 0) {
          return done(new Error("no nodes available for " + serviceName));
        } else {
          idx = Math.round(Math.random() * (nodes.length - 1));
          node = nodes[idx];
          return done(null, node);
        }
      });
    };


    /**
     * returns all nodes registered for the specified service.
     */

    ServiceInfoCache.prototype.getNodes = function(serviceName, done) {
      var cached;
      cached = this._getFromLocalCache(serviceName);
      if (cached != null) {
        return nextTick(function() {
          return done(null, cached);
        });
      } else {
        return this._getFromRedis(serviceName, (function(_this) {
          return function(err, instances) {
            if (err != null) {
              return done(err);
            } else {
              _this._addToLocalCache(serviceName, instances);
              return done(null, instances);
            }
          };
        })(this));
      }
    };

    ServiceInfoCache.prototype._getFromLocalCache = function(serviceName) {
      var elapsed, entry;
      entry = this._cache[serviceName];
      if (entry != null) {
        elapsed = Date.now() - entry.timestamp;
        if (elapsed > this._cacheTtlMillis) {
          delete this._cache[serviceName];
          return null;
        } else {
          return entry.value;
        }
      }
    };

    ServiceInfoCache.prototype._getFromRedis = function(serviceName, done) {
      var key, redisClient;
      key = util.format(SERVICE_KEY_FORMAT, serviceName);
      redisClient = this.redisClientManager.getPrimaryCacheClient();
      return redisClient.hgetall(key, (function(_this) {
        return function(err, nodesHash) {
          var alive, ref, zombies;
          if (err != null) {
            return done(err);
          } else if (nodesHash == null) {
            return done(null, []);
          } else {
            ref = _this._splitLiveFromZombies(nodesHash), alive = ref[0], zombies = ref[1];
            if (zombies.length > 0) {
              logger.info({
                zombies: zombies
              }, "cleaning zombie nodes");
              redisClient.hdel([key].concat(zombies), function(err) {
                if (err != null) {
                  return logger.error(err, "failed to kill zombie service node entries", {
                    key: key,
                    zombies: zombies
                  });
                }
              });
            }
            return done(null, alive);
          }
        };
      })(this));
    };

    ServiceInfoCache.prototype._addToLocalCache = function(serviceName, nodes) {
      return this._cache[serviceName] = {
        timestamp: Date.now(),
        nodes: nodes
      };
    };

    ServiceInfoCache.prototype._splitLiveFromZombies = function(nodesHash) {
      var nodes;
      nodes = Object.keys(nodesHash);
      return _.partition(nodes, (function(_this) {
        return function(node) {
          var lastSeenSince, nodeInfo, nodeJson;
          nodeJson = nodesHash[node];
          nodeInfo = JSON.parse(nodeJson);
          lastSeenSince = Date.now() - nodeInfo.lastSeen;
          return lastSeenSince < _this._settings.ttlMillis;
        };
      })(this));
    };

    return ServiceInfoCache;

  })();

  module.exports = function() {
    var args, cache;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return cache = (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(ServiceInfoCache, args, function(){});
  };

}).call(this);
