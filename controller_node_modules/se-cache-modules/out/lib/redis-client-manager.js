(function() {
  var EventEmitter, RedisClientManager, async, aws, logger, netUtils, notificationChannel, notificationEventType, redis, util,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  util = require('util');

  async = require('async');

  aws = require('aws-sdk');

  EventEmitter = require('events').EventEmitter;

  redis = require('redis');

  netUtils = require('se-common-utils').netUtils;

  logger = require('se-logger-helper').logger();

  notificationChannel = 'redis_client_manager_channel';

  notificationEventType = 'new_replication_group_topology';


  /**
   * Class that manage the connections with the Redis caches running in a cluster of AWS Elasticache.
   */

  RedisClientManager = (function(superClass) {
    extend(RedisClientManager, superClass);


    /**
    * Constructor of RedisClientManager object
    * @param {Object} elastiCache when not null used for mocking, otherwise shall be null
    * @param {Object} redisClient when not null used for mocking, otherwise shall be null
     */

    function RedisClientManager(config, services) {
      this.replicaNodes = [];
      this.reconfiguringOnGoing = false;
      this.notificationSubscriberClient = null;
      this.elastiCache = services.elastiCache, this.redisModule = services.redisModule;
      if (this.redisModule == null) {
        this.redisModule = redis;
      }
      config.aws = false;
      if (config.aws) {
        this.awsSupported = true;
        this.replicationGroupId = config.aws.replicationGroupId;
        if (config.aws.config != null) {
          aws.config.update(config.aws.config);
        }
        if (this.elastiCache == null) {
          this.elastiCache = new aws.ElastiCache();
        }
      } else {
        this.awsSupported = false;
        this.primaryNode = {
          name: "local",
          host: "nam-02500-rg.xerbcm.ng.0001.usw2.cache.amazonaws.com",
          port: 6379
        };
      }
    }


    /**
    * Get the Primary Cache Client (used for writing in the cache) Public
    * @param  {Function} done the continuation callback
     */

    RedisClientManager.prototype.getPrimaryCacheClient = function() {
      return this.primaryNode.redisClient;
    };


    /**
    * Get one of the Replica Cache Client (used for reading from the cache) Public
    * (round-robin of all available Replica Cache Clients)
    * @param  {Function} done the continuation callback
     */

    RedisClientManager.prototype.getReplicaCacheClient = function() {
      var randomIndex;
      if (this.replicaNodes.length === 0) {
        return this.primaryNode.redisClient;
      } else if (this.replicaNodes.length === 1) {
        return this.replicaNodes[0].redisClient;
      } else {
        randomIndex = Math.floor(Math.random() * this.replicaNodes.length);
        return this.replicaNodes[randomIndex].redisClient;
      }
    };

    RedisClientManager.prototype.getSubscriberClient = function() {
      return this.notificationSubscriberClient;
    };


    /**
    * Force the Primary and Replicas clients to reconnect (needed when we got a Primary Cache Node failover) Public
    * @param {boolean} broadcastNotification when set to true will broadcast to every other server-apps the notificationMessage
    * @param  {Function} done the continuation callback
     */

    RedisClientManager.prototype.reconfigureReplicaGroupTopology = function(broadcastNotification, done) {
      if (this.reconfiguringOnGoing) {
        return done();
      } else {
        return this.getReplicaGroupTopology((function(_this) {
          return function(err, topology) {
            if (err != null) {
              return done(err);
            } else {
              if (topology.primary.name === _this.primaryNode.name) {
                return done();
              } else {
                logger.info({
                  old_redis_primary_node: _this.primaryNode.name,
                  old_redis_replica_node: _this.replicaNodes.map(function(replica) {
                    return replica.name;
                  })
                }, "Reconfiguring the Replica Group Topology...");
                _this.reconfiguringOnGoing = true;
                return async.parallel({
                  createMasterClient: function(next) {
                    return _this.createRedisClient(topology.primary.host, topology.primary.port, next);
                  },
                  createReplicaClients: function(next) {
                    return async.map(topology.replicas, function(replica, next) {
                      return _this.createRedisClient(replica.host, replica.port, next);
                    }, next);
                  },
                  createSubscribeClient: function(next) {
                    return _this.createRedisClient(topology.replicas[0].host, topology.replicas[0].port, next);
                  }
                }, function(err, connections) {
                  var event, i, index, j, len, len1, newReplicaNodes, ref, ref1, ref2, ref3, replica, replicaNode;
                  if (err != null) {
                    _this.reconfiguringOnGoing = false;
                    return done(err);
                  } else {
                    topology.primary.redisClient = connections.createMasterClient;
                    if ((ref = _this.primaryNode.redisClient) != null) {
                      ref.end();
                    }
                    _this.primaryNode = topology.primary;
                    newReplicaNodes = [];
                    ref1 = topology.replicas;
                    for (index = i = 0, len = ref1.length; i < len; index = ++i) {
                      replica = ref1[index];
                      replicaNode = {
                        name: replica.name,
                        host: replica.host,
                        port: replica.port,
                        redisClient: connections.createReplicaClients[index]
                      };
                      newReplicaNodes.push(replicaNode);
                    }
                    ref2 = _this.replicaNodes;
                    for (j = 0, len1 = ref2.length; j < len1; j++) {
                      replica = ref2[j];
                      if ((ref3 = replica.redisClient) != null) {
                        ref3.end();
                      }
                    }
                    _this.replicaNodes = newReplicaNodes;
                    _this.forceReconnectOnGroing = false;
                    _this.notificationSubscriberClient = connections.createSubscribeClient;
                    _this.notificationSubscriberClient.subscribe(notificationChannel);
                    logger.info({
                      new_redis_primary_node: _this.primaryNode.name,
                      new_redis_replica_node: _this.replicaNodes.map(function(replica) {
                        return replica.name;
                      })
                    });
                    _this.emit('redis-event', 'new-primary-client');
                    if (broadcastNotification) {
                      event = {
                        type: notificationEventType,
                        payload: {
                          from: netUtils.getNetworkAddress()
                        }
                      };
                      connections.createMasterClient.publish(notificationChannel, JSON.stringify(event));
                    }
                    _this.reconfiguringOnGoing = false;
                    return done();
                  }
                });
              }
            }
          };
        })(this));
      }
    };

    RedisClientManager.prototype.getReplicaGroupTopology = function(done) {
      var params;
      params = {
        MaxRecords: 100,
        ReplicationGroupId: this.replicationGroupId
      };
      return this.elastiCache.describeReplicationGroups(params, (function(_this) {
        return function(err, data) {
          var i, len, member, nodeGroup, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, replica, topology;
          if (err != null) {
            logger.error(err.stack);
            return done(err);
          } else {
            if (data.ReplicationGroups.length === 0 || ((ref = data.ReplicationGroups[0]) != null ? ref.ReplicationGroupId : void 0) !== _this.replicationGroupId) {
              return done(new Error(("Cannot retrieve Replication Group information from AWS, expected: " + _this.replicationGroupId + " got: ") + ((ref1 = data.ReplicationGroups[0]) != null ? ref1.ReplicationGroupId : void 0)));
            } else if (((ref2 = data.ReplicationGroups[0]) != null ? ref2.Status : void 0) !== 'available') {
              return done(new Error("Replication Group status is not available, currentStatus: " + ((ref3 = data.ReplicationGroups[0]) != null ? ref3.Status : void 0)));
            } else if (((ref4 = data.ReplicationGroups[0]) != null ? (ref5 = ref4.NodeGroups[0]) != null ? ref5.length : void 0 : void 0) === 0) {
              return done(new Error("Node Groups of ReplicationGroups is empty"));
            } else {
              nodeGroup = (ref6 = data.ReplicationGroups[0]) != null ? ref6.NodeGroups[0] : void 0;
              if (nodeGroup.Status !== 'available') {
                return done(new Error("Node Group status is not available"));
              } else {
                topology = {
                  replicas: [],
                  primary: {
                    host: null,
                    port: null,
                    name: null
                  }
                };
                ref7 = nodeGroup.NodeGroupMembers;
                for (i = 0, len = ref7.length; i < len; i++) {
                  member = ref7[i];
                  if (member.CurrentRole === 'primary') {
                    topology.primary.name = member.CacheClusterId;
                    topology.primary.host = member.ReadEndpoint.Address;
                    topology.primary.port = member.ReadEndpoint.Port;
                  } else {
                    replica = {
                      host: member.ReadEndpoint.Address,
                      port: member.ReadEndpoint.Port,
                      name: member.CacheClusterId
                    };
                    topology.replicas.push(replica);
                  }
                }
                return done(null, topology);
              }
            }
          }
        };
      })(this));
    };

    RedisClientManager.prototype.createRedisClient = function(host, port, done) {
      var client;
      client = this.redisModule.createClient(port, host);
      client.on('error', function(err) {
        return logger.error(err);
      });
      client.on('ready', function() {
        logger.info({
          host: host,
          port: port
        }, "Redis connection established");
        return done(null, client);
      });
      return client.on('message', (function(_this) {
        return function(channel, event) {
          var error;
          if (channel === notificationChannel) {
            logger.info({
              channel: channel,
              event: event
            }, "Event received");
            try {
              event = JSON.parse(event);
              if (event.type === notificationEventType && event.payload.from !== netUtils.getNetworkAddress()) {
                return _this.reconfigureReplicaGroupTopology(false, function(err) {
                  if (err != null) {
                    return logger.error("[redis-client-manager] Unable to reconfigure the Redis Replication Group topology");
                  }
                });
              }
            } catch (_error) {
              error = _error;
              return logger.error(err, event, "[redis-client-manager] JSON Parsing error");
            }
          }
        };
      })(this));
    };

    RedisClientManager.prototype.init = function(done) {
      var host, name, port, ref, self;
      self = this;
      if (this.awsSupported) {
        return this.getReplicaGroupTopology((function(_this) {
          return function(err, topology) {
            if (err != null) {
              return done(err);
            } else {
              return async.parallel({
                createMasterClient: function(next) {
                  return _this.createRedisClient(topology.primary.host, topology.primary.port, next);
                },
                createReplicaClients: function(next) {
                  return async.map(topology.replicas, function(replica, next) {
                    return _this.createRedisClient(replica.host, replica.port, next);
                  }, next);
                },
                createSubscribeClient: function(next) {
                  var ref;
                  if (((ref = topology.replicas) != null ? ref.length : void 0) < 1) {
                    return next(new Error("The replication group topology must have at least one replica"));
                  } else {
                    return _this.createRedisClient(topology.replicas[0].host, topology.replicas[0].port, next);
                  }
                }
              }, function(err, connections) {
                var i, index, len, ref, replica, replicaNode;
                if (err != null) {
                  return done(err);
                } else {
                  _this.primaryNode = topology.primary;
                  _this.primaryNode.redisClient = connections.createMasterClient;
                  ref = topology.replicas;
                  for (index = i = 0, len = ref.length; i < len; index = ++i) {
                    replica = ref[index];
                    replicaNode = {
                      name: replica.name,
                      host: replica.host,
                      port: replica.port,
                      redisClient: connections.createReplicaClients[index]
                    };
                    _this.replicaNodes.push(replicaNode);
                  }
                  _this.notificationSubscriberClient = connections.createSubscribeClient;
                  _this.notificationSubscriberClient.subscribe(notificationChannel);
                  return done();
                }
              });
            }
          };
        })(this));
      } else {
        ref = self.primaryNode, name = ref.name, host = ref.host, port = ref.port;
        return async.parallel([
          function(done) {
            return self.createRedisClient(host, port, function(err, client) {
              if (err != null) {
                return done(err);
              } else {
                self.primaryNode.redisClient = client;
                return done();
              }
            });
          }, function(done) {
            return self.createRedisClient(host, port, function(err, client) {
              var replicaNode;
              if (err != null) {
                return done(err);
              } else {
                replicaNode = {
                  name: name,
                  host: host,
                  port: port,
                  redisClient: client
                };
                self.replicaNodes.push(replicaNode);
                return done();
              }
            });
          }, function(done) {
            return self.createRedisClient(host, port, function(err, client) {
              if (err != null) {
                return done(err);
              } else {
                self.notificationSubscriberClient = client;
                return done();
              }
            });
          }
        ], function() {
          return done();
        });
      }
    };

    return RedisClientManager;

  })(EventEmitter);

  module.exports = function(serviceDirectory, services, done) {
    var config, redisClientManager, ref;
    if (done == null) {
      done = services;
      services = null;
    }
    if (services == null) {
      services = {};
    }
    config = (ref = serviceDirectory != null ? serviceDirectory.redis : void 0) != null ? ref : {
      host: 'localhost',
      port: '6379'
    };
    logger.info("Creating a RedisClientManager");
    redisClientManager = new RedisClientManager(config, services);
    return redisClientManager.init(function(err) {
      if (err != null) {
        return done(err);
      } else {
        return done(null, redisClientManager);
      }
    });
  };

}).call(this);
