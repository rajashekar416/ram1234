'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _ = require('lodash');
var StatsDClient = require('statsd-client');

var SCOPE_SEP = '.';

module.exports = {
  /**
   * create a new metrics instance, configured with the supplied configuration.
   * @param  {Object} config        the metrics configuration
   * @param  {Object} StatsdClient  the statsd client implementation
   * @return {Object} metrics       the root metrics instance
   */
  create: function create() {
    var config = arguments[0] === undefined ? {} : arguments[0];

    if (undefined === config.enabled) {
      config.enabled = 'true' === process.env.METRICS_ENABLED;
    }
    var statsd = config.enabled ? new StatsDClient(_.omit(config, 'enabled')) : null;
    return new Metrics(statsd);
  }
};

var Metrics = (function () {
  function Metrics(statsd) {
    _classCallCheck(this, Metrics);

    this._statsd = statsd;
    this.enabled = null != statsd;

    // for each statsd-client method, add a proxy method to the Metrics class prototype
    var methods = ['timing', 'increment', 'decrement', 'counter', 'gauge', 'gaugeDelta', 'set'];
    var noop = function noop() {};
    methods.forEach((function (method) {
      this[method] = this.enabled ? this._statsd[method].bind(this._statsd) : noop;
    }).bind(this));
  }

  _createClass(Metrics, [{
    key: 'createTimer',

    /**
     * create a Timer instance
     * @param  {String}   label    the label of the future timing event
     * @return {Object}   timer    the created timer
     */
    value: function createTimer(label) {
      return new Timer(this, label);
    }
  }, {
    key: 'createTimerSet',

    /**
     * create a TimerSet instance
     * @param  {String}   label    the label of the future timing event
     * @return {Object}   timer    the created timer set
     */
    value: function createTimerSet(prefix) {
      return new TimerSet(this, prefix);
    }
  }, {
    key: 'timeCallback',

    /**
     * wraps the supplied callback by timing the time until it is called.
     * @param  {String}    label     the label of the future timing event
     * @param  {Function}  callback  the wrapped callback
     * @return {Object}    timer     the created timer set
     */
    value: function timeCallback(label, callback) {
      var timers = this.createTimerSet();
      timers.start(label);
      return timers.timeCallback(callback);
    }
  }, {
    key: 'createExpressMiddleware',

    /**
     * creates an express middleware that will add timing for all requests
     * @return {Object} an express middleware
     */
    value: function createExpressMiddleware() {
      if (this._statsd) {
        var middleware = this._statsd.helpers.getExpressMiddleware('req', { timeByUrl: true });
        return middleware;
      }
    }
  }, {
    key: 'createScope',

    /**
     * create a new Metrics instance scoped to the supplied prefix
     * @param  {string}   prefix    the prefix of the new Metrics object
     * @return {Metrics}  metrics   the scoped metric object
     */
    value: function createScope(prefix) {
      return new Metrics(this._statsd && this._statsd.getChildClient(prefix));
    }
  }]);

  return Metrics;
})();

/**
 * convencience object that times the elapsed time between it instanciation and the call to .end()
 */

var Timer = (function () {
  function Timer(metrics, label) {
    _classCallCheck(this, Timer);

    this._started = Date.now();
    this._metrics = metrics;
    this._label = label;
  }

  _createClass(Timer, [{
    key: 'end',

    /**
     * ends the timer, emitting a timing event if err is null.
     * otherwise an increment on [label].error is emitted.
     * @param  {Error} err  [optional] the error, if any.
     */
    value: function end(err) {
      if (this._checkNotCalled()) {
        if (null != err) {
          this._metrics.increment(this._label + '.error');
        } else {
          var elapsed = Date.now() - this._started;
          this._metrics.timing(this._label, elapsed);
        }
      }
    }
  }, {
    key: '_checkNotCalled',
    value: function _checkNotCalled() {
      if (true === this._endCalled) {
        logger.warn('end has already been called on this timer');
      } else {
        this._endCalled = true;
        return true;
      }
    }
  }]);

  return Timer;
})();

/**
 * a timer set, with a common prefix
 */

var TimerSet = (function () {
  function TimerSet(metrics, prefix) {
    _classCallCheck(this, TimerSet);

    this._metrics = metrics;
    this._scopedMetrics = metrics.createScope(prefix);
    this._prefix = prefix;
    this._timers = {};
  }

  _createClass(TimerSet, [{
    key: 'start',

    /**
     * start a new timer with the supplied label
     * @param  {String} label   the label of the timer. can be empty to use only the TimerSet prefix;
     */
    value: function start(label) {
      label = _normalizeLabel(label);
      this._timers[label] = _.isEmpty(label) ? this._metrics.createTimer(this._prefix) : this._scopedMetrics.createTimer(label);
    }
  }, {
    key: 'endAll',

    /**
     * ends all the timers created to at this time.
     * @param  {Error} err  [optional] the error, if any.
     */
    value: function endAll(err) {
      var _this = this;

      Object.keys(this._timers).forEach(function (label) {
        return _this.end(label, err);
      });
    }
  }, {
    key: 'end',

    /**
      * ends the timer with the specified label.
      * @param  {String} label the label of timer to end.
      * @param  {Error}  err   [optional] the error, if any.
      */
    value: function end(label, err) {
      var timer = this._popTimer(label);
      if (timer != null) {
        timer.end(err);
      }
    }
  }, {
    key: '_popTimer',
    value: function _popTimer(label) {
      label = _normalizeLabel(label);
      var timer = this._timers[label];
      if (null == timer) {
        logger.warn('timer ' + label + ' not found');
      } else {
        delete this._timers[label];
      }

      return timer;
    }
  }, {
    key: 'timeCallback',

    /**
     * wraps the supplied callback, calling endAll when invoked.
     * @param  {Function} callback The callback to wrap.
     * @return {Function}          The wrapping callback.
     */
    value: function timeCallback(callback) {
      var _this2 = this;

      var wrapperCallback = function wrapperCallback(err) {
        for (var _len = arguments.length, results = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          results[_key - 1] = arguments[_key];
        }

        _this2.endAll(err);
        callback.apply(undefined, [err].concat(results));
      };

      return wrapperCallback;
    }
  }]);

  return TimerSet;
})();

function _normalizeLabel(label) {
  if (null == label) {
    return '';
  } else {
    return label.trim();
  }
}
//# sourceMappingURL=metrics.js.map
