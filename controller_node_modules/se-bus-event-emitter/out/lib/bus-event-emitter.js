(function() {
  var DEFAULT_CIRCUIT_BREAKER_CONFIG, DEFAULT_RETRY_CONFIG, ERROR_CODES, _, levee, logger, minimatch, netUtils, util, uuidGen,
    slice = [].slice;

  minimatch = require('minimatch');

  util = require('util');

  netUtils = require('se-common-utils').netUtils;

  _ = require('lodash');

  levee = require('levee');

  uuidGen = require('node-uuid');

  logger = require('se-logger-helper').logger().child({
    module: module
  });

  ERROR_CODES = Object.freeze({
    ERR_TIMEOUT: 'ERR_TIMEOUT'
  });

  DEFAULT_RETRY_CONFIG = Object.freeze({
    responseTimeout: 1500,
    maxRetryCount: 6,
    backoffFactor: 200
  });

  DEFAULT_CIRCUIT_BREAKER_CONFIG = Object.freeze({
    maxFailures: 5,
    timeout: 10000,
    resetTimeout: 30000
  });


  /**
   * @param  {Object} context                    the application context
   * @param  {Function} getChannelTargetHostPort function called when emitting. It should
   *                                             return a host and port in its callback
   */

  module.exports = function(context, getChannelTargetHostPort) {
    var BusEventEmitter, _breakers, _channel, _channelFormat, _circuitBreakerConfig, _config, _convertErrorToObject, _eventManagerInstance, _getUuid, _isSystemError, _isValidEvent, _listeners, _metrics, _networkIp, _nullUuid, _pubConx, _publishEvent, _redisClientManager, _subConx, ref, ref1;
    _eventManagerInstance = null;
    _networkIp = netUtils.getNetworkAddress();
    _config = context.config;
    _redisClientManager = context.redisClientManager;
    _metrics = (ref = context.metrics) != null ? ref.createScope('event-bus') : void 0;
    _channelFormat = "serverIp:%s:serverPort:%s";
    _channel = util.format(_channelFormat, _networkIp, _config.SERVER_TCP_PORT);
    _listeners = {};
    _circuitBreakerConfig = _.merge({
      isFailure: function(err) {
        return err.errorCode === ERROR_CODES.ERR_TIMEOUT;
      }
    }, DEFAULT_CIRCUIT_BREAKER_CONFIG, (ref1 = _config.busEventEmitter) != null ? ref1.circuitBreaker : void 0);
    _breakers = Object.create(null);
    _pubConx = _redisClientManager.getPrimaryCacheClient();
    _subConx = _redisClientManager.getSubscriberClient();
    _nullUuid = "null-uuid";

    /**
     * Validates if an error returned from a req-res message response
     * is considered a system error that would trigger a retry of the request
     *
     * @param  {Object}  error the error object returned from the message payload
     * @return {Boolean}       true if it's a system error, false otherwise
     */
    _isSystemError = function(error) {
      return ((error != null ? error.statusCode : void 0) != null) && error.statusCode > 400;
    };

    /**
     * Converts non innumerable error properties to a plain object
     *
     * @param  {Error} error the error instance object
     * @return {Object}      the plain error object
     */
    _convertErrorToObject = function(error) {
      var plainObj;
      if (error != null) {
        plainObj = _.toPlainObject(error);
        plainObj.message = error.message;
        return plainObj;
      }
    };

    /**
     * Returns a fake uuid in case of a request message pattern
     * so the handler can be stored in a bucket under labels > types > uuids
     *
     * @param  {Object} event the message event
     * @return {String}       the uuid used as a bucket under "labels > types" to store the handler
     */
    _getUuid = function(event) {
      if ((event.responseChannel != null) || (event.uuid == null)) {
        return _nullUuid;
      } else {
        return event.uuid;
      }
    };
    _isValidEvent = function(event) {
      return (event != null) && _.isArray(event.labels) && (event.type != null);
    };
    BusEventEmitter = function() {
      var _self;
      _self = this;
      logger.info({
        channel: _channel
      }, "Event manager using channel");
      _subConx.on('message', function(channel, event) {
        var e, i, key, label, len, listenerKeys, ref2, results, targetListeners, uuid;
        if (event != null) {
          try {
            event = JSON.parse(event);
          } catch (_error) {
            e = _error;
            logger.error(e, {
              event: event,
              channel: channel
            });
          }
          if ((event.labels != null) && (event.type != null)) {
            ref2 = event.labels;
            results = [];
            for (i = 0, len = ref2.length; i < len; i++) {
              label = ref2[i];
              targetListeners = _listeners[label];
              if (!_.isEmpty(targetListeners)) {
                listenerKeys = _.filter(_.keys(targetListeners), function(key) {
                  return minimatch(event.type, key);
                });
                results.push((function() {
                  var j, len1, results1;
                  results1 = [];
                  for (j = 0, len1 = listenerKeys.length; j < len1; j++) {
                    key = listenerKeys[j];
                    logger.debug({
                      listener_key: key,
                      event: event
                    }, "Calling listener:");
                    uuid = _getUuid(event);
                    if ((targetListeners[key][uuid] != null) && _.isFunction(targetListeners[key][uuid])) {
                      results1.push(targetListeners[key][uuid](event));
                    } else {
                      results1.push(logger.warn({
                        key: key,
                        uuid: uuid,
                        target_listener_uuid: targetListeners[key][uuid]
                      }, "Skipping event"));
                    }
                  }
                  return results1;
                })());
              } else {
                results.push(void 0);
              }
            }
            return results;
          }
        }
      });
      return _subConx.subscribe(_channel);
    };
    _publishEvent = function(stringEvent, labels, getChannelTargetHostPort) {
      var i, label, len, results;
      results = [];
      for (i = 0, len = labels.length; i < len; i++) {
        label = labels[i];
        results.push(getChannelTargetHostPort(label, function(err, channel) {
          var stringChannel;
          if (err != null) {
            return logger.error(err, {
              channel: channel
            }, "Error while getting host and port in 'getChannelTargetHostPort'");
          } else if (channel != null) {
            stringChannel = util.format(_channelFormat, channel.host, channel.port);
            logger.debug({
              channel: channel,
              event: stringEvent
            }, "Publishing event");
            return _pubConx.publish(stringChannel, stringEvent);
          }
        }));
      }
      return results;
    };

    /**
     * Emits an event which usually has a payload value
     * @param  {Object} event the event object formatted as {labels: [<String | Number>], type: <String>, payload: <String>}
     */
    BusEventEmitter.prototype.emit = function(event) {
      var ref2, stringEvent;
      if (_isValidEvent(event)) {
        event.req_id = (ref2 = process.domain) != null ? ref2.id : void 0;
        stringEvent = JSON.stringify(event);
        if ((event.channel != null) && (event.channel.host != null) && (event.channel.port != null)) {
          return _publishEvent(stringEvent, event.labels, function(label, done) {
            return done(null, event.channel);
          });
        } else if (getChannelTargetHostPort != null) {
          return _publishEvent(stringEvent, event.labels, getChannelTargetHostPort);
        } else {
          return _publishEvent(stringEvent, event.labels, function(label, done) {
            return done(null, {
              host: _networkIp,
              port: _config.SERVER_TCP_PORT
            });
          });
        }
      } else {
        return logger.error({
          event: event
        }, "The event parameter should be an object\nformatted as {labels: [<String | Number>], type: <String>, payload: <String>}.  The\npayload property is optional.");
      }
    };

    /**
     * Registers a listener to be executed when the passed event
     * pattern is matched
     * @param  {Object} event      the event pattern to match on
     * @param  {Function} listener the function to execute when a matching event is triggered
     */
    BusEventEmitter.prototype.on = function(event, listener) {
      var i, label, len, ref2, ref3, results, uuid;
      if (_isValidEvent(event) && _.isFunction(listener)) {
        ref2 = event.labels;
        results = [];
        for (i = 0, len = ref2.length; i < len; i++) {
          label = ref2[i];
          _listeners[label] = _listeners[label] || {};
          uuid = _getUuid(event);
          if (((ref3 = _listeners[label][event.type]) != null ? ref3[uuid] : void 0) != null) {
            logger.warn({
              label: label,
              event_type: event.type
            }, "The listener for label and type is being overwritten.");
            delete _listeners[label][event.type][uuid];
          }
          _listeners[label][event.type] = _listeners[label][event.type] || {};
          results.push(_listeners[label][event.type][uuid] = listener);
        }
        return results;
      } else {
        return logger.error({
          event: event
        }, "The event parameter should be an object\nformatted as {labels: [<values>], type: <type>}. A listener function\nis also mandatory.");
      }
    };

    /**
     * Returns a list of listeners matching the passed event
     * @param  {Object} event the event pattern
     * @return {Array}        the list of listeners matching the event pattern
     */
    BusEventEmitter.prototype.listeners = function(event) {
      var i, label, len, listener, listeners, ref2, ref3, type;
      listeners = [];
      if ((event != null ? event.labels : void 0) != null) {
        ref2 = event.labels;
        for (i = 0, len = ref2.length; i < len; i++) {
          label = ref2[i];
          if (_listeners[label] != null) {
            if ((event.type != null) && (_listeners[label][event.type] != null)) {
              listeners.push(_listeners[label][event.type]);
            } else if (_.isPlainObject(_listeners[label])) {
              ref3 = _listeners[label];
              for (type in ref3) {
                listener = ref3[type];
                listeners.push(listener);
              }
            } else {
              listeners.push(_listeners[label]);
            }
          }
        }
      }
      return listeners;
    };

    /**
     * Removes all registered listener matching the passed event
     * @param  {Object} event the event pattern to match
     */
    BusEventEmitter.prototype.removeAllListeners = function(event) {
      var i, label, len, ref2, ref3, results;
      if ((event != null) && (event.labels != null)) {
        ref2 = event.labels;
        results = [];
        for (i = 0, len = ref2.length; i < len; i++) {
          label = ref2[i];
          if (event.type != null) {
            results.push((ref3 = _listeners[label]) != null ? delete ref3[event.type] : void 0);
          } else {
            results.push(delete _listeners[label]);
          }
        }
        return results;
      }
    };

    /**
     * Request response convenience function.
     * @param  {Object}   event           the request event
     * @param  {Number}   responseTimeout the time to wait for a response before timing out
     * @param  {Function} done            the continuation callback
     */
    BusEventEmitter.prototype.request = function(event, responseTimeout, done) {
      if (_.size(event.labels) !== 1) {
        return done(new Error("A req-res operation event must have exactly one label"));
      } else {
        return getChannelTargetHostPort(event.labels[0], (function(_this) {
          return function(err, channel) {
            var breaker, breakerKey;
            if (channel != null) {
              breakerKey = channel.host + ":" + channel.port + ":" + event.labels[0];
              breaker = _breakers[breakerKey];
              if (breaker == null) {
                breaker = _breakers[breakerKey] = levee.createBreaker(_this._request.bind(_this), _circuitBreakerConfig);
              }
              event.channel = channel;
              return breaker.run(event, responseTimeout, done);
            }
          };
        })(this));
      }
    };

    /**
     * Really send a request after sanity checks have been made.
     */
    BusEventEmitter.prototype._request = function(event, responseTimeout, done) {
      var _finalize, _triggerTimeoutError, timeoutID, timer, uuid;
      uuid = uuidGen.v4();
      event.uuid = uuid;
      timer = _metrics != null ? _metrics.createTimer(event.type + '.' + event.labels[0]) : void 0;
      _finalize = function() {
        var args, err;
        err = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (!_finalize._called) {
          if (timer != null) {
            timer.end(err);
          }
          delete _listeners[uuid];
          _finalize._called = true;
          return done.apply(null, [err].concat(slice.call(args)));
        }
      };
      _triggerTimeoutError = function() {
        var err;
        err = new Error("[" + event.type + "] req-res event attempt timed out");
        err.errorCode = ERROR_CODES.ERR_TIMEOUT;
        return _finalize(err);
      };
      timeoutID = setTimeout(_triggerTimeoutError, responseTimeout);
      this.on({
        labels: [uuid],
        type: event.type,
        uuid: uuid
      }, function(event) {
        var res;
        clearTimeout(timeoutID);
        if (event.error == null) {
          delete event.uuid;
          delete event.channel;
          res = event;
        } else {
          res = null;
        }
        return _finalize(event.error, res);
      });
      event.responseLabel = uuid;
      event.responseChannel = {
        host: _networkIp,
        port: _config.SERVER_TCP_PORT
      };
      return this.emit(event);
    };

    /**
     * Request response function, with retries. They retryOptions object supports the following
     * settings:
     *  - responseTimeout : the responseTimeout to pass to request (default 500ms)
     *  - maxRetryCount   : the maximum number of retries (default 4)
     *  - backoffFactor   : wait retryIdx * backoffFactor between retries (default 125ms)
     *
     * @param  {Object}   event        the request event
     * @param  {Object}   retryOptions  the retry parameters (optional)
     * @param  {Function} done         the continuation callback
     */
    BusEventEmitter.prototype.retryRequest = function(event, retryOptions, done) {
      var _shouldRetry, _try, backoffFactor, fullRetryConfig, maxRetryCount, responseTimeout, retryIdx, self;
      self = this;
      if (done == null) {
        done = retryOptions;
        retryOptions = null;
      }
      fullRetryConfig = _.merge({}, DEFAULT_RETRY_CONFIG, retryOptions);
      responseTimeout = fullRetryConfig.responseTimeout, maxRetryCount = fullRetryConfig.maxRetryCount, backoffFactor = fullRetryConfig.backoffFactor;
      retryIdx = 0;
      _try = function() {
        return self.request(event, responseTimeout, function() {
          var delay, err, res;
          err = arguments[0], res = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          retryIdx += 1;
          if (_shouldRetry(err)) {
            delay = Math.ceil(backoffFactor * Math.random() * Math.pow(2, retryIdx - 1));
            return setTimeout(_try, delay);
          } else {
            return done.apply(null, [err].concat(slice.call(res)));
          }
        });
      };
      _shouldRetry = function(err) {
        var isTimeoutErr, maxRetriesReached;
        isTimeoutErr = (err != null ? err.errorCode : void 0) === ERROR_CODES.ERR_TIMEOUT;
        maxRetriesReached = retryIdx >= maxRetryCount;
        return isTimeoutErr && !maxRetriesReached;
      };
      return _try();
    };

    /**
     * emits an event in response to a request
     *
     * @param  {Object} event                the matching event pattern
     * @param  {Function} processingCallback the processing callback.  Its signature should
     *                                       be 'cb(event, done(err, result))'
     */
    BusEventEmitter.prototype.respondTo = function(event, processingCallback) {
      var self;
      self = this;
      return this.on({
        labels: event.labels,
        type: event.type
      }, function(event) {
        var origEvent;
        origEvent = _.clone(event);
        return processingCallback(event, function(err, payload) {
          return self.emit({
            labels: [origEvent.responseLabel],
            type: origEvent.type,
            channel: origEvent.responseChannel,
            uuid: origEvent.uuid,
            error: _convertErrorToObject(err),
            payload: payload
          });
        });
      });
    };
    BusEventEmitter.prototype.removeListener = BusEventEmitter.prototype.removeAllListeners;
    return _eventManagerInstance != null ? _eventManagerInstance : _eventManagerInstance = new BusEventEmitter();
  };

}).call(this);
