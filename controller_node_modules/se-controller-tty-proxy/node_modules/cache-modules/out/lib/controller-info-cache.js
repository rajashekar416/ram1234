(function() {
  var ControllerInfoCache, EventEmitter, async, netUtils, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  async = require('async');

  util = require('util');

  EventEmitter = require('events').EventEmitter;

  netUtils = require('se-common-utils').netUtils;


  /**
   * Class that provides a structure to store controller related information.
   * the provided exposed functions.
   */

  ControllerInfoCache = (function() {
    function ControllerInfoCache(redisClientManager, cloudServerHost, cloudServerPort) {
      this.redisClientManager = redisClientManager;
      this.cloudServerHost = cloudServerHost;
      this.cloudServerPort = cloudServerPort;
      this.getBySocketId = __bind(this.getBySocketId, this);
      this.getByName = __bind(this.getByName, this);
      this.clearSocketIdHash = __bind(this.clearSocketIdHash, this);
      this.removeBySocketId = __bind(this.removeBySocketId, this);
      this.removeByName = __bind(this.removeByName, this);
      this.add = __bind(this.add, this);
      this.removeController = __bind(this.removeController, this);
      this.keyPatterns = {
        lookupBySocketIdHashName: "controllers:lookup:socketId:" + this.cloudServerHost + "_" + this.cloudServerPort,
        lookupBySocketIdKey: "socketId:%s",
        controllerNameKey: "controller:%s:json"
      };
    }

    ControllerInfoCache.prototype.removeController = function(controllerName, socketId, removeByName, done) {
      var socketIdKeyFormatted;
      if (controllerName != null) {
        socketIdKeyFormatted = util.format(this.keyPatterns.lookupBySocketIdKey, socketId);
        return async.auto({
          getClient: (function(_this) {
            return function(done) {
              return done(null, _this.redisClientManager.getPrimaryCacheClient());
            };
          })(this),
          byName: [
            'getClient', (function(_this) {
              return function(done, results) {
                if (removeByName === true) {
                  return results.getClient.del(util.format(_this.keyPatterns.controllerNameKey, controllerName), done);
                } else {
                  return done();
                }
              };
            })(this)
          ],
          bySocketId: [
            'getClient', (function(_this) {
              return function(done, results) {
                logger.info({
                  socket_id_hash_name: _this.keyPatterns.lookupBySocketIdHashName,
                  socket_id_lookup_pattern: socketIdKeyFormatted,
                  remove_by_name_flag: removeByName
                }, "Remove Controller by socketID");
                return results.getClient.hdel(_this.keyPatterns.lookupBySocketIdHashName, socketIdKeyFormatted, done);
              };
            })(this)
          ]
        }, (function(_this) {
          return function(err, results) {
            if (err != null) {
              logger.error(err, "Got error when trying to write to redis");
              if (err.toString().indexOf('READONLY') !== -1) {
                _this.redisClientManager.reconfigureReplicaGroupTopology(true, function(err) {
                  if (err != null) {
                    return logger.error(err, "Unable to reconfigure the Redis Replication Group topology");
                  }
                });
              }
              return done(err);
            } else {
              return done();
            }
          };
        })(this));
      } else {
        return done();
      }
    };


    /**
     * Adds a controller info map to the mapping.
     *
     * @param {String}           name           the id used to identify the controller in urls
     * @param {Number or String} socketId       the id used to identify a client socket in BinaryJs
     * @param {Object}           targetHttpInfo the target Host and Port information (used for url mangling)
     */

    ControllerInfoCache.prototype.add = function(name, socketId, targetHttpInfo, done) {
      var controllerInfo, controllerKeyFormated, jsonController, socketIdKeyFormatted;
      if (name == null) {
        return done(new Error("Cannot add a controller without name"));
      } else if (socketId == null) {
        return done(new Error("Cannot add a controller without socket Id"));
      } else {
        controllerInfo = {
          name: name,
          socketId: "" + socketId,
          cloudServerHost: this.cloudServerHost,
          cloudServerPort: this.cloudServerPort,
          targetHttpServerHost: targetHttpInfo.targetHttpServerHost,
          targetHttpServerPort: targetHttpInfo.targetHttpServerPort
        };
        jsonController = JSON.stringify(controllerInfo, null, 2);
        socketIdKeyFormatted = util.format(this.keyPatterns.lookupBySocketIdKey, socketId);
        controllerKeyFormated = util.format(this.keyPatterns.controllerNameKey, name);
        return async.auto({
          getClient: (function(_this) {
            return function(done) {
              return done(null, _this.redisClientManager.getPrimaryCacheClient());
            };
          })(this),
          byName: [
            'getClient', (function(_this) {
              return function(done, results) {
                logger.info({
                  controller_name: name,
                  controller_key: controllerKeyFormated,
                  socket_id_hash_ame: _this.keyPatterns.lookupBySocketIdHashName,
                  socket_id_lookup_pattern: socketIdKeyFormatted
                }, "Adding a controller to the cache");
                return results.getClient.set(controllerKeyFormated, jsonController, done);
              };
            })(this)
          ],
          bySocketId: [
            'getClient', (function(_this) {
              return function(done, results) {
                return results.getClient.hset(_this.keyPatterns.lookupBySocketIdHashName, socketIdKeyFormatted, name, done);
              };
            })(this)
          ]
        }, (function(_this) {
          return function(err, results) {
            if (err != null) {
              logger.error(err, "Got error when trying to write to redis");
              if (err.toString().indexOf('READONLY') !== -1) {
                _this.redisClientManager.reconfigureReplicaGroupTopology(true, function(err) {
                  if (err != null) {
                    return logger.error(err, "Unable to reconfigure the Redis Replication Group topology");
                  }
                });
              }
              return done(err);
            } else {
              return done();
            }
          };
        })(this));
      }
    };


    /**
     * Removes a controler info map object by its controller name
     * @param  {Strind} name the controller name
     */

    ControllerInfoCache.prototype.removeByName = function(name, done) {
      if (name != null) {
        return this.getByName(name, (function(_this) {
          return function(err, controller) {
            if (err != null) {
              return done(err, null);
            } else {
              return _this.removeController(controller != null ? controller.name : void 0, controller != null ? controller.socketId : void 0, true, function(err, res) {
                return done(err, controller);
              });
            }
          };
        })(this));
      } else {
        return done(new Error('Cannot remove a controller without name'));
      }
    };


    /**
     * Removes a controller info map by its corresponding client socket id
     * @param  {Number or String} id the binaryJs client socket id
     */

    ControllerInfoCache.prototype.removeBySocketId = function(socketId, done) {
      if (socketId != null) {
        return this.getBySocketId(socketId, (function(_this) {
          return function(err, controller) {
            var removeByName;
            if (err != null) {
              return done(err, null);
            } else if (controller == null) {
              return done();
            } else {
              removeByName = (controller != null ? controller.socketId : void 0) === socketId.toString() && (controller != null ? controller.cloudServerHost : void 0) === _this.cloudServerHost && (controller != null ? controller.cloudServerPort : void 0) === _this.cloudServerPort;
              logger.info("" + _this.cloudServerHost + " " + _this.cloudServerPort);
              return _this.removeController(controller.name, socketId, removeByName, function(err, res) {
                return done(err, controller);
              });
            }
          };
        })(this));
      } else {
        return done(new Error('Cannot remove a controller without socketId'));
      }
    };


    /**
     * Clears the socket id to controller name hash mapping.
     * Invoked whenever the server restarts so we're in a clean state without
     * invalid mappings)
     * @param  {Function} done the continuation callback
     */

    ControllerInfoCache.prototype.clearSocketIdHash = function(done) {
      var client;
      client = this.redisClientManager.getPrimaryCacheClient();
      return client.del(this.keyPatterns.lookupBySocketIdHashName, done);
    };


    /**
     * @param  {String} name the controller name
     * @return {Object}    an immutable version of the controller map object
     */

    ControllerInfoCache.prototype.getByName = function(name, done) {
      var client;
      if (done == null) {
        throw new Error('You need to give a callback to the function.');
      }
      if (name != null) {
        client = this.redisClientManager.getReplicaCacheClient();
        return client.get(util.format(this.keyPatterns.controllerNameKey, name), function(err, jsonController) {
          if (jsonController != null) {
            jsonController = JSON.parse(jsonController);
          }
          return done(err, jsonController);
        });
      } else {
        return done(new Error('Cannot get a controller without name', null));
      }
    };


    /**
     * @param  {Number or String} id the BinaryJs client socket id
     * @return {Object}    an immutable version of the controller map object
     */

    ControllerInfoCache.prototype.getBySocketId = function(socketId, done) {
      var client, socketIdKey;
      if (socketId != null) {
        client = this.redisClientManager.getReplicaCacheClient();
        socketIdKey = util.format(this.keyPatterns.lookupBySocketIdKey, socketId);
        return client.hget(this.keyPatterns.lookupBySocketIdHashName, socketIdKey, (function(_this) {
          return function(err, controllerName) {
            return _this.getByName(controllerName, function(err, controller) {
              return done(err, controller);
            });
          };
        })(this));
      } else {
        return done(new Error('Cannot get a controller without socketId', null));
      }
    };

    return ControllerInfoCache;

  })();

  module.exports = function(redisClientManager, port) {
    var controllerInfoCache;
    logger.info("Creating a ControllerInfoCache for " + (netUtils.getNetworkAddress()) + ":" + port);
    return controllerInfoCache = new ControllerInfoCache(redisClientManager, netUtils.getNetworkAddress(), port);
  };

}).call(this);
