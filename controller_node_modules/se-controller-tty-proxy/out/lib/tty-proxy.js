(function() {
  var BinaryClient, BinaryServer, connect, cookie, netUtils, streamTypeEnum, stringutils, ttyConfig, util;

  cookie = require("cookie");

  connect = require("connect");

  util = require('util');

  BinaryServer = require('se-binaryjs').BinaryServer;

  BinaryClient = require('se-binaryjs').BinaryClient;

  netUtils = require('se-common-utils').netUtils;

  stringutils = require('se-common-utils').stringutils;

  streamTypeEnum = require('se-common-utils').streamTypeEnum;

  ttyConfig = require('../../config.json');

  module.exports = function(context, controllerConnectionManager) {
    var bindServerToBrowser, bindServerToServer, browserConnections, closeControllerStream, cloudControllerConnections, cloudServerConnections, config, controllerInfoCache, createWsBrowserServer, createWsProxyServer, disconnectBrowser, disconnectCloudServer, handleBrowserConx, handleProxyCloudConnection, networkIp, proxyWebSocketConnection, registerOnConnectionEventListener, ttySessionManager;
    controllerConnectionManager = controllerConnectionManager;
    ttySessionManager = require('./tty-session-manager').getInstance(context);
    controllerInfoCache = context.controllerInfoCache;
    config = context.config;
    networkIp = netUtils.getNetworkAddress();
    browserConnections = {};
    cloudControllerConnections = {};
    cloudServerConnections = {};

    /**
     * Send a message to tty and disconnect after 3 seconds
     * @param  {String}   controllerUuid Controller Uuid to disconnect
     * @param  {String}   message        Message to print
     */
    disconnectBrowser = function(controllerUuid, message) {
      var browserConnection, username;
      if (browserConnections[controllerUuid] != null) {
        browserConnection = browserConnections[controllerUuid].connection;
        username = browserConnections[controllerUuid].username;
        delete browserConnections[controllerUuid];
        if (browserConnection != null) {
          browserConnection.removeAllListeners();
        }
        ttySessionManager.closeSession(username, controllerUuid);
        if (browserConnection != null ? browserConnection.writable : void 0) {
          browserConnection.write({
            type: 'data',
            data: message
          });
        }
        return setTimeout(function() {
          return browserConnection != null ? browserConnection.end() : void 0;
        }, 5000);
      }
    };

    /**
     * Close the controller stream
     * @param  {String}   controllerUuid Controller Uuid to disconnect
     */
    closeControllerStream = function(controllerUuid) {
      var cloudControllerConnection;
      if (cloudControllerConnections[controllerUuid] != null) {
        cloudControllerConnection = cloudControllerConnections[controllerUuid];
        cloudControllerConnection.removeAllListeners();
        cloudControllerConnection.end();
        return delete cloudControllerConnections[controllerUuid];
      }
    };

    /**
     * Disconnects from cloud server
     * @param  {String}   controllerUuid Controller Uuid to disconnect
     */
    disconnectCloudServer = function(controllerUuid) {
      var cloudServerConnection, interval;
      if (cloudServerConnections[controllerUuid] != null) {
        cloudServerConnection = cloudServerConnections[controllerUuid].connection;
        interval = cloudServerConnections[controllerUuid].interval;
        delete cloudServerConnections[controllerUuid];
        clearInterval(interval);
        if (cloudServerConnection != null) {
          cloudServerConnection.removeAllListeners();
        }
        return cloudServerConnection != null ? cloudServerConnection.close() : void 0;
      }
    };

    /**
     * Generic function that forwards events emmitted from browser to proxy.
     * @param  {Object}   browserConnection         BinaryJs socket
     * @param  {Object}   cloudServerConnection     binary js stream
     * @param  {Function} onDisconnect              a function to be executed uppon receiving a 'disconnect' event
     */
    bindServerToBrowser = function(controllerUuid, browserConnection, cloudServerConnection) {
      browserConnection.on('data', function(data) {
        if (data.type === "ping") {
          return browserConnection.write({
            type: "pong"
          });
        } else {
          return cloudServerConnection.write(data);
        }
      });
      browserConnection.on('close', function() {
        logger.debug("Got 'close' event from browser.");
        delete browserConnections[controllerUuid];
        disconnectCloudServer(controllerUuid);
        return closeControllerStream(controllerUuid);
      });
      browserConnection.on('error', function(err) {
        logger.error("Got 'error' event from browser (Reason: " + err + ").");
        return disconnectCloudServer(controllerUuid);
      });
      cloudServerConnection.on('data', function(data) {
        return browserConnection.write(data);
      });
      cloudServerConnection.on('close', function() {
        logger.debug("Got 'close' event from cloud controller !");
        delete cloudServerConnections[controllerUuid];
        return disconnectBrowser(controllerUuid, "You have been disconnected (controller went offline or another user has started a new session).");
      });
      cloudServerConnection.on('error', function(err) {
        return logger.error("Got 'error' event from cloud controller (Reason: " + err + ").");
      });
      return browserConnection.write({
        type: 'registered'
      });
    };

    /**
     * Used to forward connection from another server-app to a cloud controller connected to this server-app
     * @param  {Object}   cloudServerConnection     binary js stream from server-app instance
     * @param  {Object}   cloudControllerConnection binary js stream from cloud- controller instance
     * @param  {Function} onDisconnect              a function to be executed uppon receiving a 'disconnect' event
     */
    bindServerToServer = function(controllerUuid, cloudServerConnection, cloudControllerConnection) {
      cloudServerConnection.on('data', function(data) {
        return cloudControllerConnection.write(data);
      });
      cloudServerConnection.on('close', function() {
        logger.debug("Got 'close' event from server-app.");
        delete cloudServerConnections[controllerUuid];
        return closeControllerStream(controllerUuid);
      });
      cloudServerConnection.on('error', function(err) {
        logger.error("Got 'error' event from cloud server (" + err + ").");
        return closeControllerStream(controllerUuid);
      });
      cloudControllerConnection.on('data', function(data) {
        return cloudServerConnection.write(data);
      });
      cloudControllerConnection.on('close', function() {
        logger.debug("Got 'close' event from controller.");
        delete cloudControllerConnections[controllerUuid];
        return disconnectCloudServer(controllerUuid);
      });
      return cloudControllerConnection.on('error', function(err) {
        return logger.error("Got 'error' event from cloud controller (" + err + ").");
      });
    };

    /**
     * Handles BinaryJs connections comming from browsers trying to
     * connect to cloud controllers served by a remote server-app
     * @param  {String} controllerUuid the cloud controller UUID
     * @param  {Object} browserConx    the BinaryJs client connection
     */
    proxyWebSocketConnection = function(controllerUuid, controllerCacheInfo, browserConx) {
      var proxyWebSocketClient, wsProxyUri;
      if (ttyConfig.WEBSOCKET_TTY_SUBSCRIBE_PATH != null) {
        ttyConfig.WEBSOCKET_TTY_SUBSCRIBE_PATH = stringutils.prefix(ttyConfig.WEBSOCKET_TTY_SUBSCRIBE_PATH, '/');
      } else {
        ttyConfig.WEBSOCKET_TTY_SUBSCRIBE_PATH = '/';
      }
      wsProxyUri = ("ws://" + controllerCacheInfo.cloudServerHost + ":" + ttyConfig.WEBSOCKET_TTY_PROXYING_PORT) + ("" + ttyConfig.WEBSOCKET_TTY_SUBSCRIBE_PATH);
      logger.debug("Connecting to %s", wsProxyUri);
      proxyWebSocketClient = new BinaryClient(wsProxyUri);
      proxyWebSocketClient.on('open', function() {
        var err, proxyingStream;
        try {
          proxyingStream = proxyWebSocketClient.createStream({
            controllerUuid: controllerUuid
          });
          cloudServerConnections[controllerUuid] = {
            connection: proxyWebSocketClient,
            interval: null
          };
          return bindServerToBrowser(controllerUuid, browserConx, proxyingStream);
        } catch (_error) {
          err = _error;
          logger.error("Cannot create proxy stream, reason: " + err + ".");
          proxyWebSocketClient.close();
          return disconnectBrowser(controllerUuid, "The controller has been disconnected... Please try again in a few minutes.");
        }
      });
      return proxyWebSocketClient.on('error', function(err) {
        logger.error("Websocket connection error: " + err);
        return disconnectBrowser(controllerUuid, "The controller has been disconnected... Please try again in a few minutes.");
      });
    };

    /**
     * Handles BinaryJs connections comming from browsers
     * @param  {String} controllerUuid    the target cloud controller UUID
     * @param  {Object} browserConnection the BinaryJs client connection
     */
    handleBrowserConx = function(username, controllerUuid, browserConnection) {
      logger.info("Configuring an incoming browser connection for " + controllerUuid);
      disconnectBrowser(controllerUuid, "Another user has been connected, you have been disconnected.");
      closeControllerStream(controllerUuid);
      if (browserConnections[controllerUuid] != null) {
        ttySessionManager.closeSession(browserConnections[controllerUuid].username, controllerUuid);
      }
      browserConnections[controllerUuid] = {};
      browserConnections[controllerUuid].connection = browserConnection;
      browserConnections[controllerUuid].username = username;
      return controllerInfoCache.getByName(controllerUuid, function(err, controllerCacheInfo) {
        if ((err != null) || (controllerCacheInfo == null)) {
          logger.error("Controller " + controllerUuid + " is not currently connected");
          return disconnectBrowser(controllerUuid, "The controller is currently not connected. Please try again in a few minutes.");
        } else if (controllerCacheInfo.cloudServerHost !== networkIp || controllerCacheInfo.cloudServerPort !== config.SERVER_TCP_PORT) {
          return proxyWebSocketConnection(controllerUuid, controllerCacheInfo, browserConnection);
        } else {
          return controllerConnectionManager.createStream(controllerUuid, streamTypeEnum.TTY_SESSION, function(err, cloudControllerConnection) {
            if (err != null) {
              logger.error("Cannot create stream to cloud controller, reason " + err + ".");
              return disconnectBrowser(controllerUuid, "The controller is currently not connected. Please try again in a few minutes.");
            } else {
              cloudControllerConnections[controllerUuid] = cloudControllerConnection;
              return bindServerToBrowser(controllerUuid, browserConnection, cloudControllerConnection);
            }
          });
        }
      });
    };

    /**
     * Handles BinaryJs connections comming from server-app instance
     * @param  {String} controllerUuid    the target cloud controller UUID
     * @param  {Object} cloudServerClient the binaryJs client connection (client)
     * @param  {Object} cloudServerSocket the binaryJs controller connection (stream)
     */
    handleProxyCloudConnection = function(controllerUuid, cloudServerClient, cloudServerSocket) {
      disconnectBrowser(controllerUuid, "Another user has been connected, you have been disconnected.");
      closeControllerStream(controllerUuid);
      if (cloudServerConnections[controllerUuid] == null) {
        cloudServerConnections[controllerUuid] = {};
      }
      cloudServerConnections[controllerUuid].connection = cloudServerClient;
      return controllerConnectionManager.createStream(controllerUuid, streamTypeEnum.TTY_SESSION, function(err, cloudControllerConnection) {
        if (err != null) {
          logger.error("Cannot create stream to cloud controller, reason: " + err + ".");
          return disconnectCloudServer(controllerUuid);
        } else {
          logger.info("Forwarding request to '" + controllerUuid + "'.");
          cloudControllerConnections[controllerUuid] = cloudControllerConnection;
          return bindServerToServer(controllerUuid, cloudServerSocket, cloudControllerConnection);
        }
      });
    };

    /**
     * Creates an unsecure web Socket server (should be internal).
     * It is used between 2 server-app instances.
     */
    createWsProxyServer = function() {
      var webSocketProxyServerOptions;
      webSocketProxyServerOptions = {
        host: "0.0.0.0",
        port: ttyConfig.WEBSOCKET_TTY_PROXYING_PORT,
        path: ttyConfig.WEBSOCKET_TTY_SUBSCRIBE_PATH
      };
      return new BinaryServer(webSocketProxyServerOptions);
    };

    /**
     * Creates an instance of a seocketio server
     * @param  {Object or Number} listenHook can either be the httpServer instance or a port number
     */
    createWsBrowserServer = function(listenHook) {
      var wsBrowserServer;
      wsBrowserServer = {
        server: listenHook,
        host: "0.0.0.0",
        path: ttyConfig.WEBSOCKET_TTY_SUBSCRIBE_PATH
      };
      return new BinaryServer(wsBrowserServer);
    };

    /**
     * Registers an incoming connection.
     * It could be either 'public', 'proxy' or a 'cloud-controller'.
     * - public connection: a client through a browser tries to access to a cloud-controller
     * - proxy connection : a client through a browser and another server-app instance tries to acces
     *                      to a cloud-controller
     * - cloud-controller : a cloud-controller tries to register itself to the server-app instance.
     * @param  {Object} socket Can either be the BinaryJs client or a binary js stream
     * @param  {String} type   Can either be a 'public', 'proxy' or a 'cloud-controller' connection.
     */
    registerOnConnectionEventListener = function(socket, type) {
      return socket.on('connection', function(client) {
        return client.on('stream', function(stream, meta) {
          switch (type) {
            case 'proxy':
              if (meta.controllerUuid == null) {
                logger.error("Unable to forward request, reason: controllerUuid is null.");
                return client.close();
              } else {
                return handleProxyCloudConnection(meta.controllerUuid, client, stream);
              }
              break;
            case 'public':
              logger.info("Got 'init' event from '" + meta.data.username + "' user to '" + meta.data.controllerUuid + "' controller.");
              if (meta.type === 'init' && meta.data.origin === 'browser' && type === 'public') {
                return ttySessionManager.isSessionValid(meta.data.username, meta.data.controllerUuid, meta.data.token, function(err, isValid) {
                  if ((err != null) || !isValid) {
                    logger.error("Closing session due to: '" + (err || 'invalid token') + "'");
                    return client.close();
                  } else {
                    return handleBrowserConx(meta.data.username, meta.data.controllerUuid, stream);
                  }
                });
              } else {
                return client.close();
              }
              break;
            default:
              logger.error("Unknown connection incoming, closing connection.");
              return client.close();
          }
        });
      });
    };
    return {

      /**
       * Starts the tty proxy server.
       * @param  {Object} httpServer HTTP server used by server-app
       */
      start: function(httpServer) {
        var proxyingWsServer, publicWsServer;
        if (controllerConnectionManager != null) {
          proxyingWsServer = createWsProxyServer();
          return registerOnConnectionEventListener(proxyingWsServer, 'proxy');
        } else {
          publicWsServer = createWsBrowserServer(httpServer);
          return registerOnConnectionEventListener(publicWsServer, 'public');
        }
      }
    };
  };

}).call(this);
