// Generated by CoffeeScript 1.9.3
(function() {
  var _, _bindUncaughtExceptionHandler, _controllerSerializer, _loadStreams, _moduleSerializer, _monitorLogLevels, _reqSerializer, _userSerializer, bunyan, bunyanEmit, defaultLogger, fs, getDefaultLogger, monitorTimeout, optionsFileWatcher, packageJson, path, requireDir, routeAccessLogMiddleware, uncaughtExceptionHandlerBound, util;

  util = require('util');

  bunyan = require('bunyan');

  packageJson = require(process.cwd() + '/package.json');

  _ = require('lodash');

  requireDir = require('require-dir');

  fs = require('fs');

  path = require('path');

  defaultLogger = null;

  uncaughtExceptionHandlerBound = false;

  monitorTimeout = null;

  optionsFileWatcher = null;


  /**
   * Injects the active execution context ID in the log message
   * if it exists
   */

  bunyanEmit = bunyan.prototype._emit;

  bunyan.prototype._emit = function(rec, noemit) {
    if (process.domain != null) {
      rec.req_id = process.domain.id;
    }
    return bunyanEmit.call(this, rec, noemit);
  };

  _bindUncaughtExceptionHandler = function() {
    if (!uncaughtExceptionHandlerBound) {
      uncaughtExceptionHandlerBound = true;
      return process.on('uncaughtException', function(err) {
        if (defaultLogger != null) {
          defaultLogger.error(err, "\u2622 UncaughtException \u2622");
        } else {
          console.error("\u2622 UncaughtException \u2622: " + err.message);
          console.error(err.stack);
        }
        return process.exit(1);
      });
    }
  };


  /**
   * Converts objects with key 'user'
   * @param  {Object} user a user model instance
   * @return {Object}            a sanitized user instance
   */

  _userSerializer = function(user) {
    if ((user != null) && !_.isString(user)) {
      user = {
        user_id: user._id,
        user_name: user.username
      };
    }
    return user;
  };


  /**
   * Converts objects with key 'controller'
   * @param  {Object} controller a controller model instance
   * @return {Object}            a sanitized controller instance
   */

  _controllerSerializer = function(controller) {
    var ref;
    if ((controller != null) && !_.isString(controller)) {
      controller = {
        uuid: (ref = controller.name) != null ? ref : controller.uuid,
        device_name: controller.deviceName
      };
    }
    return controller;
  };


  /**
   * Converts objects with key 'req'
   * @param  {Object} req the http request object
   * @return {Object}     the sanitized request object
   */

  _reqSerializer = function(req) {
    if (((req != null ? req.connection : void 0) != null) || ((req != null ? req.headers : void 0) != null)) {
      req = {
        method: req.method,
        url: req.url,
        header: req.headers
      };
      _.assign(req, _controllerSerializer(req.controller));
      _.assign(req, _userSerializer(req.user));
    }
    return req;
  };


  /**
   * Converts a module object to its filename
   * @param  {Object} module a module instance
   * @return {String}        the module's filename
   */

  _moduleSerializer = function(module) {
    if ((module != null ? module.filename : void 0) != null) {
      module = path.basename(module.filename);
    }
    return module;
  };


  /**
   * Loads bunyan stream modules from a given directory
   * @return {Array} an array of stream modules
   */

  _loadStreams = function(streamsPath) {
    var nodeEnv, streams;
    if (streamsPath != null) {
      nodeEnv = process.env.NODE_ENV || 'development';
      streams = _.values(requireDir(streamsPath));
      return streams = _.filter(streams, function(stream) {
        var eligible;
        eligible = _.contains(stream.env, nodeEnv);
        if (eligible && _.isFunction(stream.init)) {
          stream.init();
        }
        return eligible;
      });
    }
  };


  /**
   * Monitors the log levels file and changes corresponding
   * streams' log level accordingly
   * @param  {String} optionsFilePath the path to the config file
   */

  _monitorLogLevels = function(optionsFilePath) {
    var refreshLevels, refreshing;
    refreshing = false;
    refreshLevels = function() {
      refreshing = true;
      defaultLogger.debug("Reloading log levels", optionsFilePath);
      clearTimeout(monitorTimeout);
      return monitorTimeout = setTimeout(function() {
        var err, i, len, ref, stream, streamOptions;
        delete require.cache[require.resolve(optionsFilePath)];
        streamOptions = require(optionsFilePath);
        try {
          ref = defaultLogger.streams;
          for (i = 0, len = ref.length; i < len; i++) {
            stream = ref[i];
            defaultLogger.levels(stream.name, streamOptions[stream.name]);
          }
        } catch (_error) {
          err = _error;
          defaultLogger.error(err);
        }
        return refreshing = false;
      }, 100);
    };
    if (optionsFilePath != null) {
      refreshLevels();
      if (optionsFileWatcher != null) {
        optionsFileWatcher.close();
      }
      return optionsFileWatcher = fs.watchFile(optionsFilePath, function(curr, prev) {
        if (!refreshing) {
          return refreshLevels();
        }
      });
    }
  };


  /**
   * Middleware logging express routes' accesses
   * @param  {String} level  the min level at which logs will be emitted
   */

  routeAccessLogMiddleware = function(level) {
    var expressBunyan;
    if (level == null) {
      level = 'trace';
    }
    expressBunyan = require('express-bunyan-logger')({
      genReqId: false,
      logger: defaultLogger
    });
    return function(req, res, next) {
      if ((bunyan.levelFromName[level] >= defaultLogger.level()) && req.method !== 'OPTIONS') {
        return expressBunyan(req, res, next);
      } else {
        return next();
      }
    };
  };


  /**
   * Returns the default logger with its serializers and
   * streams initialized and bound
   * @return {Object} a bunyan logger
   */

  getDefaultLogger = function(streamsPath) {
    var i, len, ref, ref1, stream;
    if (defaultLogger == null) {
      defaultLogger = bunyan.createLogger({
        name: packageJson.name,
        level: 'debug',
        serializers: {
          req: _reqSerializer,
          res: bunyan.stdSerializers.res,
          err: bunyan.stdSerializers.err,
          controller: _controllerSerializer,
          module: _moduleSerializer
        }
      });
    }
    if (streamsPath != null) {
      if ((ref = defaultLogger.streams) != null) {
        ref.length = 0;
      }
      ref1 = _loadStreams(streamsPath);
      for (i = 0, len = ref1.length; i < len; i++) {
        stream = ref1[i];
        defaultLogger.addStream(stream);
      }
    }
    return defaultLogger;
  };

  module.exports = {
    routeAccessLogMiddleware: routeAccessLogMiddleware,
    logger: function(arg) {
      var handleUncaughtExceptions, logLevelsConfPath, logger, ref, streamsPath;
      ref = arg != null ? arg : {}, streamsPath = ref.streamsPath, logLevelsConfPath = ref.logLevelsConfPath, handleUncaughtExceptions = ref.handleUncaughtExceptions;
      if ((handleUncaughtExceptions == null) || handleUncaughtExceptions) {
        _bindUncaughtExceptionHandler();
      }
      logger = getDefaultLogger(streamsPath);
      _monitorLogLevels(logLevelsConfPath);
      return logger;
    }
  };

}).call(this);
