(function() {
  var REQUEST_LINE_RE, buildHeadersDictFromRawHeaders, buildRawHttpHeadersFromDict, buildRawHttpHeadersFromRequest, getStatusCodeFromRawHeaders, getStatusFromRawHeaders, httpStatus, parseRequestHeaders, parseResponseHeaders, prefixAbsoluteHrefsWith, proxyHeaders, replaceHostAndPortInHrefs, url, util, _;

  _ = require('lodash');

  util = require('util');

  url = require('url');

  httpStatus = require('http-status');

  REQUEST_LINE_RE = /^([A-Z]+)\s+([^\s]+)\s+HTTP\/(\d+\.\d+)$/;

  parseResponseHeaders = function(rawHeaders) {
    var headers, status;
    status = getStatusFromRawHeaders(rawHeaders);
    if (status != null) {
      headers = buildHeadersDictFromRawHeaders(rawHeaders);
      return _.merge({
        headers: headers
      }, status);
    }
  };

  /**
   * Transforms a dictionary of key/value pairs into its string representation compatible with the HTTP headers format.
   * @param  {object} dict A dictionary of key/value pairs representing HTTP headers' name/value.
   * @return {string}      A string representing the same dictionary but as a plain HTTP header.
  */


  buildRawHttpHeadersFromDict = function(dict) {
    var headerField, headerName, headerValue, rawHeaders;
    rawHeaders = '';
    for (headerName in dict) {
      headerValue = dict[headerName];
      headerField = headerName + ': ' + headerValue + '\r\n';
      rawHeaders += headerField;
    }
    return rawHeaders;
  };

  /**
   * Trandforms a request object into raw HTTP headers.
   * @param  {http.IncomingMessage} req a request object passed by node to a callback.
   * @return {string} A string representing the request's header but as a plain HTTP header.
  */


  buildRawHttpHeadersFromRequest = function(req) {
    var path, rawHeaders, uri;
    if (req.url != null) {
      uri = url.parse(req.url);
      path = uri.pathname;
    } else {
      path = req.path;
    }
    rawHeaders = req.method + ' ' + path + ' ' + 'HTTP/' + req.httpVersion;
    rawHeaders = rawHeaders + '\r\n' + buildRawHttpHeadersFromDict(req.headers);
    return rawHeaders;
  };

  parseRequestHeaders = function(rawRequestParamsString) {
    var headers, httpVersion, match, method, path, requestLine, _ref;
    requestLine = rawRequestParamsString.split('\r\n', 1)[0];
    match = REQUEST_LINE_RE.exec(requestLine);
    if (match != null) {
      _ref = match.slice(1), method = _ref[0], path = _ref[1], httpVersion = _ref[2];
      headers = buildHeadersDictFromRawHeaders(rawRequestParamsString);
      return {
        headers: headers,
        method: method,
        path: path,
        httpVersion: httpVersion
      };
    }
  };

  /**
   * Parses HTTP raw headers and returns a dictionary object with
   * key/value pairs representing each header name/value.
   * @param  {string} rawHeadersString the raw HTTP headers as a string.
   * @return {object} a dictionary object with key/value pairs representing each header name/value.
  */


  buildHeadersDictFromRawHeaders = function(rawHeadersString) {
    var headerName, headerTupleString, headerValue, headers, headersDict, _i, _len;
    if (rawHeadersString != null) {
      headers = rawHeadersString.split('\r\n').slice(1);
      headersDict = {};
      for (_i = 0, _len = headers.length; _i < _len; _i++) {
        headerTupleString = headers[_i];
        if (headerTupleString.length > 0) {
          headerName = headerTupleString.split(':', 1)[0];
          headerValue = headerTupleString.substring(headerName.length + 1).trim();
          headersDict[headerName.trim().toLowerCase()] = headerValue;
        }
      }
      return headersDict;
    }
  };

  /**
   * Parses raw HTTP headers and returns the HTTP status code.
   * @param  {string} rawHeadersString raw HTTP headers.
   * @return {integer}                 An integer representing the HTTP status code included in the headers.
  */


  getStatusCodeFromRawHeaders = function(rawHeadersString) {
    var status;
    status = getStatusFromRawHeaders(rawHeadersString);
    return status != null ? status.statusCode : void 0;
  };

  /**
   * Parses raw HTTP headers and returns the HTTP status code and message.
   * @param  {string} rawHeadersString raw HTTP headers.
   * @return {Object} An object representing the HTTP status code and message in the heaers
  */


  getStatusFromRawHeaders = function(rawHeadersString) {
    var headers, httpStatusCodeRegexp, httpVersion, match, statusCode, statusMessage;
    if (rawHeadersString != null) {
      headers = rawHeadersString.split('\r\n');
      headers.splice(1);
      httpStatusCodeRegexp = new RegExp('HTTP/(\\d\\.\\d) (\\d\\d\\d)(?:\\s+(.*))?');
      match = httpStatusCodeRegexp.exec(headers);
      if (match) {
        httpVersion = match[1];
        statusCode = parseInt(match[2]);
        statusMessage = match[3];
        return {
          httpVersion: httpVersion,
          statusCode: statusCode,
          statusMessage: statusMessage
        };
      }
    }
  };

  /**
   * Adds a prefix to the path of href HTML tags contained in a string when the path is absolute.
   * @param  {string} htmlContent a string representing some content that can contain href HTML tags.
   * @param  {string} hrefPrefix  the prefix to add to hrefs' paths that are absolute.
   * @return {string}             the same content as htmlContent, but with hrefs prefixed.
  */


  prefixAbsoluteHrefsWith = function(htmlContent, hrefPrefix) {
    if (htmlContent != null) {
      htmlContent = htmlContent.replace(/(href=[\"\'])(https?:\/\/[^\/]*?)?(:?)(\d+)?\/(.*?)([\"\'])/g, "$1$2$3$4" + hrefPrefix + "/$5$6");
    }
    return htmlContent;
  };

  /**
   * Replaces host and port by a different host and port in hrefs contained within some content.
   * @param  {string} htmlContent some content containing href HTML tags.
   * @param  {object} from        a dictionary with two keys host and port that specify what host and port to change in href tags.
   * @param  {[type]} to          a dictionary with two keys host and port that specify the new host and port value for the
   *                              matching href tags.
   * @return {string}             the new content with replacements made.
  */


  replaceHostAndPortInHrefs = function(htmlContent, from, to) {
    var hrefReplacerRegexp, protocol, replacementString, replacerRegexpString, sourceProtocol;
    if ((from == null) || (to == null) || (htmlContent == null)) {
      return htmlContent;
    }
    sourceProtocol = "https?:\/\/";
    if (from.protocol != null) {
      sourceProtocol = "" + from.protocol + ":\/\/";
    }
    logger.debug('from: %s, to: %s', util.inspect(from, util.inspect(to)));
    replacerRegexpString = ("(href=[\"\'])(" + sourceProtocol + ")?") + from.host;
    if (from.port != null) {
      replacerRegexpString = replacerRegexpString + ':?' + from.port + '?';
    }
    replacerRegexpString += '(\/)(.*)?([\"\'])';
    protocol = "$2";
    if (to.protocol != null) {
      protocol = "" + to.protocol + "://";
    }
    replacementString = "$1" + protocol + to.host;
    if (to.port != null) {
      replacementString += ':' + to.port;
    }
    replacementString += "$3$4$5";
    hrefReplacerRegexp = new RegExp(replacerRegexpString, 'g');
    htmlContent = htmlContent.replace(hrefReplacerRegexp, replacementString);
    return htmlContent;
  };

  /**
   * Performs some transformation on raw headers as a string and returns the transformed headers.
   * @param  {string} headers    complete raw HTTP headers.
   * @param  {object} transforms a dictionary specifying which transformations to apply to the headers.
   * The keys are the header fields' name to transform and their new value.
   * A special key named "pathReplace" exists that allows you to specify a new path for the request.
   * @return {string}            transformed raw HTTP headers.
  */


  proxyHeaders = function(headers, transforms) {
    var fromRegexp, headerName, headerValue, headersDict, headersList, request, requests, transformedHeaders, _ref;
    if (headers != null) {
      headersList = headers.split('\r\n');
      requests = headersList.splice(0, 1);
      request = null;
      if ((requests != null) && requests.length >= 1) {
        request = requests[0];
      }
      if (request != null) {
        if ((transforms != null) && (transforms.pathReplace != null)) {
          logger.debug('Replacing request line in headers...');
          logger.debug('Original: [%s]', request);
          fromRegexp = new RegExp(escape(transforms.pathReplace.from), 'g');
          request = request.replace(fromRegexp, transforms.pathReplace.to);
          logger.debug('New: [%s]', request);
        }
        headersDict = buildHeadersDictFromRawHeaders(headers);
        transformedHeaders = headers;
        logger.debug('headersDict: %s, transforms: %s', util.inspect(headersDict, util.inspect(transforms)));
        if ((headersDict != null) && (transforms != null)) {
          _ref = transforms.headers;
          for (headerName in _ref) {
            headerValue = _ref[headerName];
            logger.debug('Replace header with name [%s] with value [%s]', headerName, headerValue);
            headersDict[headerName] = headerValue;
          }
          transformedHeaders = buildRawHttpHeadersFromDict(headersDict);
        }
        return request + '\r\n' + transformedHeaders + '\r\n';
      }
    }
  };

  module.exports = {
    parseResponseHeaders: parseResponseHeaders,
    parseRequestHeaders: parseRequestHeaders,
    buildRawHttpHeadersFromDict: buildRawHttpHeadersFromDict,
    buildRawHttpHeadersFromRequest: buildRawHttpHeadersFromRequest,
    getStatusCodeFromRawHeaders: getStatusCodeFromRawHeaders,
    getStatusFromRawHeaders: getStatusFromRawHeaders,
    buildHeadersDictFromRawHeaders: buildHeadersDictFromRawHeaders,
    proxyHeaders: proxyHeaders,
    prefixAbsoluteHrefsWith: prefixAbsoluteHrefsWith,
    replaceHostAndPortInHrefs: replaceHostAndPortInHrefs
  };

}).call(this);
