(function() {
  var buildHeadersDictFromRawHeaders, buildRawHttpHeadersFromDict, buildRawHttpHeadersFromRequest, getStatusCodeFromRawHeaders, logger, prefixAbsoluteHrefsWith, proxyHeaders, replaceHostAndPortInHrefs, url, util;

  util = require('util');

  url = require('url');

  if (typeof logger === "undefined" || logger === null) {
    logger = require('winston');
  }

  /**
   * Transforms a dictionary of key/value pairs into its string representation compatible with the HTTP headers format.
   * @param  {object} dict A dictionary of key/value pairs representing HTTP headers' name/value.
   * @return {string}      A string representing the same dictionary but as a plain HTTP header.
  */


  buildRawHttpHeadersFromDict = function(dict) {
    var headerField, headerName, headerValue, rawHeaders;
    rawHeaders = '';
    for (headerName in dict) {
      headerValue = dict[headerName];
      headerField = headerName + ': ' + headerValue + '\r\n';
      rawHeaders += headerField;
    }
    return rawHeaders;
  };

  /**
   * Trandforms a request object into raw HTTP headers.
   * @param  {http.IncomingMessage} req a request object passed by node to a callback.
   * @return {string} A string representing the request's header but as a plain HTTP header.
  */


  buildRawHttpHeadersFromRequest = function(req) {
    var path, rawHeaders, uri;
    if (req.url != null) {
      uri = url.parse(req.url);
      path = uri.pathname;
    } else {
      path = req.path;
    }
    rawHeaders = req.method + ' ' + path + ' ' + 'HTTP/' + req.httpVersion;
    rawHeaders = rawHeaders + '\r\n' + buildRawHttpHeadersFromDict(req.headers);
    return rawHeaders;
  };

  /**
   * Parses HTTP raw headers and returns a dictionary object with
   * key/value pairs representing each header name/value.
   * @param  {string} rawHeadersString the raw HTTP headers as a string.
   * @return {object}                  a dictionary object with key/value pairs representing each header name/value.
  */


  buildHeadersDictFromRawHeaders = function(rawHeadersString) {
    var headerName, headerTuple, headerTupleString, headerValue, headers, headersDict, _i, _len;
    if (rawHeadersString != null) {
      headers = rawHeadersString.split('\r\n');
      headers.splice(0, 1);
      headersDict = {};
      for (_i = 0, _len = headers.length; _i < _len; _i++) {
        headerTupleString = headers[_i];
        headerTupleString = headerTupleString.substring(0);
        headerTuple = headerTupleString.split(':');
        headerName = headerTuple[0];
        if (headerName === "host") {
          headerValue = headerTuple[1];
          if (headerTuple[2] != null) {
            headerValue += ':' + headerTuple[2];
          }
        } else {
          headerValue = headerTuple[1];
        }
        if (headerValue) {
          headerValue = headerValue.substring(1);
          headersDict[headerName] = headerValue;
        }
      }
      return headersDict;
    }
  };

  /**
   * Parses raw HTTP headers and returns the HTTP status code.
   * @param  {string} rawHeadersString raw HTTP headers.
   * @return {integer}                 An integer representing the HTTP status code included in the headers.
  */


  getStatusCodeFromRawHeaders = function(rawHeadersString) {
    var headers, httpStatusCodeRegexp, match;
    if (rawHeadersString != null) {
      headers = rawHeadersString.split('\r\n');
      headers.splice(1);
      httpStatusCodeRegexp = new RegExp('HTTP/\\d\\.\\d (\\d\\d\\d).*');
      match = httpStatusCodeRegexp.exec(headers);
      if (match && match.length >= 2) {
        return parseInt(match[1]);
      }
    }
  };

  /**
   * Adds a prefix to the path of href HTML tags contained in a string when the path is absolute.
   * @param  {string} htmlContent a string representing some content that can contain href HTML tags.
   * @param  {string} hrefPrefix  the prefix to add to hrefs' paths that are absolute.
   * @return {string}             the same content as htmlContent, but with hrefs prefixed.
  */


  prefixAbsoluteHrefsWith = function(htmlContent, hrefPrefix) {
    if (htmlContent != null) {
      htmlContent = htmlContent.replace(/(href=[\"\'])(https?:\/\/[^\/]*?)?(:?)(\d+)?\/(.*?)([\"\'])/g, "$1$2$3$4" + hrefPrefix + "/$5$6");
    }
    return htmlContent;
  };

  /**
   * Replaces host and port by a different host and port in hrefs contained within some content.
   * @param  {string} htmlContent some content containing href HTML tags.
   * @param  {object} from        a dictionary with two keys host and port that specify what host and port to change in href tags.
   * @param  {[type]} to          a dictionary with two keys host and port that specify the new host and port value for the
   *                              matching href tags.
   * @return {string}             the new content with replacements made.
  */


  replaceHostAndPortInHrefs = function(htmlContent, from, to) {
    var hrefReplacerRegexp, protocol, replacementString, replacerRegexpString, sourceProtocol;
    if ((from == null) || (to == null) || (htmlContent == null)) {
      return htmlContent;
    }
    sourceProtocol = "https?:\/\/";
    if (from.protocol != null) {
      sourceProtocol = "" + from.protocol + ":\/\/";
    }
    logger.debug('from: %s, to: %s', util.inspect(from, util.inspect(to)));
    replacerRegexpString = ("(href=[\"\'])(" + sourceProtocol + ")?") + from.host;
    if (from.port != null) {
      replacerRegexpString = replacerRegexpString + ':?' + from.port + '?';
    }
    replacerRegexpString += '(\/)(.*)?([\"\'])';
    protocol = "$2";
    if (to.protocol != null) {
      protocol = "" + to.protocol + "://";
    }
    replacementString = "$1" + protocol + to.host;
    if (to.port != null) {
      replacementString += ':' + to.port;
    }
    replacementString += "$3$4$5";
    hrefReplacerRegexp = new RegExp(replacerRegexpString, 'g');
    htmlContent = htmlContent.replace(hrefReplacerRegexp, replacementString);
    return htmlContent;
  };

  /**
   * Performs some transformation on raw headers as a string and returns the transformed headers.
   * @param  {string} headers    complete raw HTTP headers.
   * @param  {object} transforms a dictionary specifying which transformations to apply to the headers.
   * The keys are the header fields' name to transform and their new value.
   * A special key named "pathReplace" exists that allows you to specify a new path for the request.
   * @return {string}            transformed raw HTTP headers.
  */


  proxyHeaders = function(headers, transforms) {
    var fromRegexp, headerName, headerValue, headersDict, headersList, request, requests, transformedHeaders, _ref;
    if (headers != null) {
      headersList = headers.split('\r\n');
      requests = headersList.splice(0, 1);
      request = null;
      if ((requests != null) && requests.length >= 1) {
        request = requests[0];
      }
      if (request != null) {
        if ((transforms != null) && (transforms.pathReplace != null)) {
          logger.debug('Replacing request line in headers...');
          logger.debug('Original: [%s]', request);
          fromRegexp = new RegExp(escape(transforms.pathReplace.from), 'g');
          request = request.replace(fromRegexp, transforms.pathReplace.to);
          logger.debug('New: [%s]', request);
        }
        headersDict = buildHeadersDictFromRawHeaders(headers);
        transformedHeaders = headers;
        logger.debug('headersDict: %s, transforms: %s', util.inspect(headersDict, util.inspect(transforms)));
        if ((headersDict != null) && (transforms != null)) {
          _ref = transforms.headers;
          for (headerName in _ref) {
            headerValue = _ref[headerName];
            logger.debug('Replace header with name [%s] with value [%s]', headerName, headerValue);
            headersDict[headerName] = headerValue;
          }
          transformedHeaders = buildRawHttpHeadersFromDict(headersDict);
        }
        return request + '\r\n' + transformedHeaders + '\r\n';
      }
    }
  };

  module.exports = {
    buildRawHttpHeadersFromDict: buildRawHttpHeadersFromDict,
    buildRawHttpHeadersFromRequest: buildRawHttpHeadersFromRequest,
    getStatusCodeFromRawHeaders: getStatusCodeFromRawHeaders,
    buildHeadersDictFromRawHeaders: buildHeadersDictFromRawHeaders,
    proxyHeaders: proxyHeaders,
    prefixAbsoluteHrefsWith: prefixAbsoluteHrefsWith,
    replaceHostAndPortInHrefs: replaceHostAndPortInHrefs
  };

}).call(this);
